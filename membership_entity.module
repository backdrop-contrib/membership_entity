<?php

/**
 * @file
 * Allows users to create membership entities.
 */

/**
 * Membership is disabled.
 */
define('MEMBERSHIP_ENTITY_DISABLED', 0);

/**
 * Membership is active.
 */
define('MEMBERSHIP_ENTITY_ACTIVE', 1);

/**
 * Implements hook_help().
 */
function membership_entity_help($path, $arg) {
  switch ($path) {
    case 'admin/config/meberships/settings':
      return '<p>' . t('This page provides general settings for memberships on your website.') . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function membership_entity_permission() {
  return array(
    'adminster memberships' => array(
      'title' => t('Administer Memberships'),
      'description' => t('Perform administration tasks for memberships.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function membership_entity_menu() {
  $items = array();

  $items['admin/structure/membeship-types'] = array(
    'title' => 'Membership types',
    'description' => 'Manage membership types.',
    'page callback' => 'membership_entity_types',
    'access arguments' => array('administer memberships'),
    'file' => 'membership_entity.types.inc',
  );
  $items['admin/structure/membership-types/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/membership-types/add'] = array(
    'title' => 'Add a membership type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('membership_entity_type_form'),
    'access arguments' => array('administer memberships'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'membership_entity.types.inc',
  );
  /*
  $items['admin/structure/membership-types/%membership_entity_type'] = array(
    'title' => 'Edit membership type',
    'title callback' => 'membership_entity_type_page_title',
    'title arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('membership_entity_type_form', 3),
    'access arguments' => array('administer memberships'),
    'file' => 'membership_entity.types.inc',
  );
  $items['admin/structure/membership-types/%membership_entity_type/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/membership-types/%membership_entity_type/delete'] = array(
    'title' => 'Delete',
    'page arguments' => array('membership_entity_type_delete_confirm', 3),
    'access arguments' => array('administer memberships'),
    'file' => 'membership_entity.types.inc',
  );
  */
  $items['admin/config/membership-entity/settings'] = array(
    'title' => 'Membership settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('membership_entity_admin_settings_form'),
    'access arguments' => array('administer memberships'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'membership_entity.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function membership_entity_admin_paths() {
  return array(
    'admin/config/membership-entity/*' => TRUE,
    // @TODO.
  );
}

/**
 * Implements hook_theme().
 */
function membership_entity_theme() {
  return array(
    // @TODO: Theme a membership
  );
}

/**
 * Implements hook_entity_info().
 */
/*
function membership_entity_entity_info() {
  $info = array(
    'membership' => array(
      'label' => t('Membership'),
      //'controller class' => 'MembershipController',
      'base table' => 'membership_entity',
      'uri callback' => 'membership_entity_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'mid',
        'bundle' => 'type',
        'label' => 'member_id',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'view modes' => array(
        'full' => array(
          'label' => t('Full membership'),
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  foreach (node_type_get_names() as $type => $name) {
    $return['node']['bundles'][$type] = array(
      'label' => $name,
      'admin' => array(
        'path' => 'admin/structure/types/manage/%node_type',
        'real path' => 'admin/structure/types/manage/' . str_replace('_', '-', $type),
        'bundle argument' => 4,
        'access arguments' => array('administer content types'),
      ),
    );
  }

  return $info;
}
*/

/**
 * Entity URI callback.
 */
/*
function membership_entity_uri($membership) {
  return array(
    'path' => 'membership/' . $membership->mid,
  );
}
*/

/**
 * Implements hook_cron().
 */
function membership_entity_cron() {
  // @TODO: Disable expired memberships.
}

/**
 * Title callback for a membership type.
 */
function membership_entity_type_page_title($type) {
  return $type->name;
}

/**
 * Returns a list of all the available membership types.
 *
 * @return
 *   An array of membership types, as objects, keyed by type.
 */
/*
function membership_entity_get_types() {
  return _node_types_build()->types;
}
*/

/**
 * Returns a list of available membership type names.
 *
 * @return
 *   An array of membership type names, keyed by type.
 */
/*
function membership_enityt_get_type_names() {
  return _node_types_build()->names;
}
*/

/**
 * Menu argument loader: loads a membership type by machine name.
 *
 * @param $name
 *   The machine name name of a node type to load, '_' is replaced with '-'.
 *
 * @return
 *   A membership type object or FALSE if $name does not exist.
 */
function membership_entity_type_load($name) {
  // @TODO.
}

/**
 * Saves a membership type to the database.
 *
 * @param $info
 *   The membership type to save, as an object.
 */
function membership_type_save($info) {
  /*
  $type = membership_type_set_defaults($info);

  $fields = array(
    'type' => (string) $type->type,
    'name' => (string) $type->name,
    'base' => (string) $type->base,
    'description' => (string) $type->description,
    'help' => (string) $type->help,
  );

  if (!$new) {
    db_update('membership_type')
      ->fields($fields)
      ->condition('type', $existing_type)
      ->execute();

    if (!empty($type->old_type) && $type->old_type != $type->type) {
      field_attach_rename_bundle('node', $type->old_type, $type->type);
    }
    module_invoke_all('node_type_update', $type);
    $status = SAVED_UPDATED;
  }
  else {
    db_insert('membership_entity_type')
      ->fields($fields)
      ->execute();

    field_attach_create_bundle('node', $type->type);

    module_invoke_all('node_type_insert', $type);
    $status = SAVED_NEW;
  }

  // Clear the node type cache.
  node_type_cache_reset();

  return $status;
  */
}

/**
 * Deletes a node type from the database.
 *
 * @param $type
 *   The machine-readable name of the node type to be deleted.
 */
/*
function node_type_delete($type) {
  $info = node_type_get_type($type);
  db_delete('node_type')
    ->condition('type', $type)
    ->execute();
  field_attach_delete_bundle('node', $type);
  module_invoke_all('node_type_delete', $info);

  // Clear the node type cache.
  node_type_cache_reset();
}
*/

/**
 * Builds and returns the list of available node types.
 *
 * The list of types is built by invoking hook_node_info() on all modules and
 * comparing this information with the node types in the {node_type} table.
 * These two information sources are not synchronized during module installation
 * until node_types_rebuild() is called.
 *
 * @param $rebuild
 *  TRUE to rebuild node types. Equivalent to calling node_types_rebuild().
 * @return
 *   An object with two properties:
 *   - names: Associative array of the names of node types, keyed by the type.
 *   - types: Associative array of node type objects, keyed by the type.
 *   Both of these arrays will include new types that have been defined by
 *   hook_node_info() implementations but not yet saved in the {node_type}
 *   table. These are indicated in the type object by $type->is_new being set
 *   to the value 1. These arrays will also include obsolete types: types that
 *   were previously defined by modules that have now been disabled, or for
 *   whatever reason are no longer being defined in hook_node_info()
 *   implementations, but are still in the database. These are indicated in the
 *   type object by $type->disabled being set to TRUE.
 */
/*
function _node_types_build($rebuild = FALSE) {
  $cid = 'node_types:' . $GLOBALS['language']->language;

  if (!$rebuild) {
    $_node_types = &drupal_static(__FUNCTION__);
    if (isset($_node_types)) {
      return $_node_types;
    }
    if ($cache = cache_get($cid)) {
      $_node_types = $cache->data;
      return $_node_types;
    }
  }

  $_node_types = (object) array('types' => array(), 'names' => array());

  foreach (module_implements('node_info') as $module) {
    $info_array = module_invoke($module, 'node_info');
    foreach ($info_array as $type => $info) {
      $info['type'] = $type;
      $_node_types->types[$type] = node_type_set_defaults($info);
      $_node_types->types[$type]->module = $module;
      $_node_types->names[$type] = $info['name'];
    }
  }
  $query = db_select('node_type', 'nt')
    ->addTag('translatable')
    ->addTag('node_type_access')
    ->fields('nt')
    ->orderBy('nt.type', 'ASC');
  if (!$rebuild) {
    $query->condition('disabled', 0);
  }
  foreach ($query->execute() as $type_object) {
    $type_db = $type_object->type;
    // Original disabled value.
    $disabled = $type_object->disabled;
    // Check for node types from disabled modules and mark their types for removal.
    // Types defined by the node module in the database (rather than by a separate
    // module using hook_node_info) have a base value of 'node_content'. The isset()
    // check prevents errors on old (pre-Drupal 7) databases.
    if (isset($type_object->base) && $type_object->base != 'node_content' && empty($_node_types->types[$type_db])) {
      $type_object->disabled = TRUE;
    }
    if (isset($_node_types->types[$type_db])) {
      $type_object->disabled = FALSE;
    }
    if (!isset($_node_types->types[$type_db]) || $type_object->modified) {
      $_node_types->types[$type_db] = $type_object;
      $_node_types->names[$type_db] = $type_object->name;

      if ($type_db != $type_object->orig_type) {
        unset($_node_types->types[$type_object->orig_type]);
        unset($_node_types->names[$type_object->orig_type]);
      }
    }
    $_node_types->types[$type_db]->disabled = $type_object->disabled;
    $_node_types->types[$type_db]->disabled_changed = $disabled != $type_object->disabled;
  }

  if ($rebuild) {
    foreach ($_node_types->types as $type => $type_object) {
      if (!empty($type_object->is_new) || !empty($type_object->disabled_changed)) {
        node_type_save($type_object);
      }
    }
  }

  asort($_node_types->names);

  cache_set($cid, $_node_types);

  return $_node_types;
}
*/

/**
 * Sets the default values for a node type.
 *
 * The defaults are appropriate for a type defined through hook_node_info(),
 * since 'custom' is TRUE for types defined in the user interface, and FALSE
 * for types defined by modules. (The 'custom' flag prevents types from being
 * deleted through the user interface.) Also, the default for 'locked' is TRUE,
 * which prevents users from changing the machine name of the type.
 *
 * @param $info
 *   An object or array containing values to override the defaults. See
 *   hook_node_info() for details on what the array elements mean.
 *
 * @return
 *   A node type object, with missing values in $info set to their defaults.
 */
/*
function node_type_set_defaults($info = array()) {
  $info = (array) $info;
  $new_type = $info + array(
    'type' => '',
    'name' => '',
    'base' => '',
    'description' => '',
    'help' => '',
    'custom' => 0,
    'modified' => 0,
    'locked' => 1,
    'disabled' => 0,
    'is_new' => 1,
    'has_title' => 1,
    'title_label' => 'Title',
  );
  $new_type = (object) $new_type;

  // If the type has no title, set an empty label.
  if (!$new_type->has_title) {
    $new_type->title_label = '';
  }
  if (empty($new_type->module)) {
    $new_type->module = $new_type->base == 'node_content' ? 'node' : '';
  }
  $new_type->orig_type = isset($info['type']) ? $info['type'] : '';

  return $new_type;
}
*/
